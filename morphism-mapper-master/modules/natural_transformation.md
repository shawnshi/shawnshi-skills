---
module: natural_transformation
version: 3
name: 自然变换引擎
description: 处理多视角对齐、颗粒度缩放及策略平滑迁移
---

## Mathematical Foundation

**自然变换 (Natural Transformation) α: F ⇒ G**：
它描述了**两个函子（观察世界的透镜）之间的平滑映射**。
不仅用于"时间t1到t2"（环境演化），更用于"视角A到视角B"（结构翻译）或"层级High到层级Low"（战略落地）。

**交换图 (The Commutative Square)**：
```
F(A) --α_A--> G(A)
   |              |
F(f)           G(f)
   |              |
   v              v
F(B) --α_B--> G(B)
```
**商业含义**：无论先在内部执行动作（Morphism），还是先切换视角（Component），最终结论必须一致。这是检验"知行合一"或"跨部门对齐"的最高数学标准。

**范畴论基础**：
给定两个函子 F, G: C → D，自然变换 α: F ⇒ G 是一族态射 α_X: F(X) → G(X)，满足交换图条件（naturality square）

## Trigger

### 自动触发
- **视角冲突**："技术和业务打架"、"老板听不懂方案"、"各部门KPI不一致"
- **落地断层**："战略很宏大落地很零碎"、"动作变形"、"为了做而做"
- **环境变化**："市场环境变了"、"行业转型"、"政策调整"、"原来的方法不管用了"

### 手动触发
- `/morphism-pivot` - 环境变化/策略演化 (Mode C)
- `/morphism-view` - 视角对齐 (Mode A)
- `/morphism-zoom` - 颗粒度缩放 (Mode B)

## Logic

### Mode A: 视角对齐 (The Rosetta Stone)
**场景**：解决 F(技术/产品) 与 G(市场/销售) 的语言不通。

1. **定义函子**：
   - F: Domain A → 视角 1 (如：工程逻辑)
   - G: Domain A → 视角 2 (如：商业逻辑)
   
2. **构建分量 (Components)**：
   - 寻找 α_X: F(X) → G(X)
   - 例：F(技术债) = "高熵代码"；G(技术债) = "交付风险溢价"
   
3. **验证交换性 (Alignment Check)**：
   - 检查动作：工程部执行"重构"(f)
   - 路径1 (F→F'): 代码质量提升
   - 路径2 (F→G→G'): 对应到商业上，是否观测到了"交付速度提升"或"维护成本降低"？
   - **判定**：若路径不闭合（工程嗨了但业务没感觉），则 α 不存在，说明"伪协同"。

### Mode B: 颗粒度缩放 (The Zoom Slider)
**场景**：解决 F(战略) 与 G(执行) 的脱节。

1. **定义函子**：
   - F: 高分辨率地图 (战略意图)
   - G: 低分辨率地图 (执行动作/JIRA工单)
   
2. **自然变换 α**: F ⇒ G (投影/降维)

3. **逆向检验 (The Integrity Test)**：
   - 将 G 中的所有微小动作 g_i 累加 (Compose)，是否等于 F 中的战略动作 f？
   - **判定**：如果 "完成所有工单" = "项目成功"，则变换自然。如果工单全做完了但项目黄了，说明出现了 **Bureaucratic Drift (科层漂移)**。

### Mode C: 动态策略演化 (The Time Evolution)
**场景**：处理环境 C1 → C2 的平滑迁移（保留 v2 核心逻辑）。

1. **识别环境变化** (Category C 的改变)：
   - 定义变化前后两个环境状态 C₁ → C₂
   - 市场结构、技术范式、政策法规、消费者行为变化

2. **评估旧函子 F 的适用性**：
   - 哪些映射关系 F(Oₐ) = Oᵦ 仍然有效？
   - 哪些因为环境变化而失效？

3. **构造新函子 G**：
   - 在不改变 Domain A 和 Domain B 的前提下，重新定义映射规则
   - G(Oₐ) = Oᵦ'（可能映射到 B 中不同的对象）

4. **寻找自然变换 α**：
   - 构造从 F 到 G 的过渡方案
   - **对象层面的连续性**：每个 Oₐ 都有明确的 F(Oₐ) → G(Oₐ) 路径
   - **关系层面的相容性**：原有 Morphism 在新旧映射中保持逻辑一致
   - **最小破坏原则**：尽量保留 F 中仍然有效的部分

5. **验证交换图**：
   - 确保无论走"旧路"还是"新路"，最终到达的 Domain B 结论应该一致（或兼容）

## Input/Output

### 输入
- **Mode A**: 两个不同视角/部门的描述 + 待对齐的关键对象
- **Mode B**: 战略描述 + 执行清单 + 成功标准
- **Mode C**: 旧策略/旧映射逻辑 F + 环境变化描述 (C₁ → C₂) + 新目标/新约束

### 输出格式

```markdown
### 【自然变换分析】

#### 模式识别：[Mode A: 视角对齐 / Mode B: 颗粒度缩放 / Mode C: 策略演化]

**1. 函子定义**：
- **Functor F (原点)**: [例如：工程师视角的系统稳定性]
- **Functor G (目标)**: [例如：CEO视角的客户留存率]

**2. 变换分量 (The Alpha Components)**：
| 关键对象 | F 视角表达 | G 视角表达 | α (翻译/映射逻辑) |
|----------|------------|------------|-------------------|
| 对象 X   | 系统宕机率 | 客户投诉量 | "1%的宕机 = 10%的客户流失风险" |
| 动作 f   | 增加冗余   | 购买保险   | "技术投入本质上是为业务买保险" |

**3. 交换图验证 (Commutativity Check)**：
- **执行动作**：[例如：投入 100万 升级服务器]
- **F 侧效果**：[并发量提升 50%]
- **G 侧预期**：[大促期间订单零损失]
- **验证结论**：✅ 闭合 / ❌ 断裂
  *(若断裂)*：警告！技术指标的提升未能转化为业务价值，建议重新设计 KPI。

**4. 模式专属分析**

##### Mode A (视角对齐) - 若适用
**对齐状态评估**：
- 当前对齐度：X%
- 断裂点识别：[列出路径不闭合的具体环节]
- 建议修复：[如何建立有效的翻译/映射]

##### Mode B (颗粒度缩放) - 若适用
**战略-执行一致性检验**：
- 战略动作分解：[F 中的关键动作]
- 执行动作累加：[所有 G 中的工单/任务]
- 科层漂移检测：✅ 无漂移 / ❌ 出现漂移
  *(若漂移)*：工单完成了但战略未达成，建议：①重新审视工单设计 ②建立战略级验收标准

##### Mode C (策略演化) - 若适用
**过渡方案**：

| 阶段 | 时间窗口 | 行动 | 风险点 |
|------|----------|------|--------|
| α₁ | 0-3个月 | ... | ... |
| α₂ | 3-6个月 | ... | ... |
| α₃ | 6-12个月 | ... | ... |

**连续性保障**：
- 客户关系：...
- 核心能力：...
- 品牌认知：...

**不可逆点识别**：
一旦执行以下动作，将无法回到旧策略：
- ...

**决策建议**：在执行 [具体节点] 前，确保 [条件] 已满足

**5. 建议方案**
建立自然变换 α 的具体行动：
1. [具体行动1]
2. [具体行动2]
3. [具体行动3]
```

## Integration

**挂载点**：
- Mode A/B: Phase 1 (Category Extraction) 之后，用于对齐不同视角的提取结果
- Mode C: Phase 3 (Functorial Mapping) 之前或之后，用于环境变化时的平滑过渡

**作用**：
- 解决"同一个问题的不同描述"之间的翻译问题
- 检测"战略与执行"之间的脱节
- 提供环境变化时的策略演化路径

**与其他模块的关系**：
- 与 `adjoint_balancer` 配合：视角对齐后评估可行性
- 与 `limits_colimits` 配合：多视角对齐后提取共同核心
- 与 `koan_break` 配合：当对齐完全失败时重构问题

### Kan Extension 调用接口

**调用机制**：当 Kan Extension 模块执行域扩展时，可根据关键词自动触发 Natural Transformation 进行结构保持验证。

**关键词映射表**：

| Kan 方向 | 触发关键词 | 调用 NT Mode | 用途 |
|----------|-----------|--------------|------|
| Left Kan | "如何过渡"、"渐进式"、"试点" | Mode C (策略演化) | 验证扩展路径的连续性 |
| Left Kan | "具体执行"、"落地细节" | Mode B (颗粒度缩放) | 确保扩展后的可执行性 |
| Right Kan | "部门协作"、"视角"、"对齐" | Mode A (视角对齐) | 协调多利益相关方 |
| Right Kan | "精准细分"、"用户画像"、"分层" | Mode B (颗粒度缩放) | 细化扩展后的颗粒度 |

**调用深度限制**：
- **最大深度：2 层**
- Kan Extension 调用 NT 计为第 1 层
- NT 内部不再触发其他模块（包括 Kan Extension 回调）
- 防止循环调用和无限递归

**调用示例**：
```
用户："如何渐进式地将现有系统扩展到新市场？"
  ↓ Kan Extension (Left Kan) 识别扩展方向
  ↓ 触发 NT Mode C - 验证过渡策略的连续性
  ↓ 输出：扩展路径 + 阶段验证检查点
```
